{% assign settings = site.data.settings['settings'] %}
{% if settings.dynamic_background != '' %}

<canvas id="webgl"></canvas>

<script>
    var imageurl = "{{ 'assets/images/' | append: settings.dynamic_background | relative_url }}";
</script>

<script type="x-shader/x-fragment" id="fragmentShader">
#define TWO_PI 6.2831853072
#define PI 3.14159265359

uniform int doInvertImage;

precision highp float;

uniform float globaltime;
uniform vec2 resolution;
uniform float aspect;
uniform float scroll;
uniform float velocity;
uniform sampler2D texture;

// Background transition (non-uniform mask) uniforms
uniform float uStart0;
uniform float uStart2;
uniform float uStartX;
uniform float uStartY;
uniform float uMultiX;
uniform float uMultiY;
uniform float uThemeMix; // 0=light,1=dark (convenience)

const float timescale = 0.03;
const float twist = 1.0;
const float scrollSpeed = 0.15;

vec2 rotate(vec2 v, float angle) {
    float c = cos(angle);
    float s = sin(angle);
    return v * mat2(c, -s, s, c);
}

float nsin(float value) {
    return sin(value * TWO_PI) * 0.5 + 0.5;
}

// --- Non-uniform transition mask (ported from our plugin shader) ---
vec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);} 
vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);} 
float cnoise(vec2 P){
  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);
  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);
  Pi = mod(Pi, 289.0);
  vec4 ix = Pi.xzxz;
  vec4 iy = Pi.yyww;
  vec4 fx = Pf.xzxz;
  vec4 fy = Pf.yyww;
  vec4 i = permute(permute(ix) + iy);
  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0;
  vec4 gy = abs(gx) - 0.5;
  vec4 tx = floor(gx + 0.5);
  gx = gx - tx;
  vec2 g00 = vec2(gx.x,gy.x);
  vec2 g10 = vec2(gx.y,gy.y);
  vec2 g01 = vec2(gx.z,gy.z);
  vec2 g11 = vec2(gx.w,gy.w);
  vec4 norm = 1.79284291400159 - 0.85373472095314 * 
    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));
  g00 *= norm.x;
  g01 *= norm.y;
  g10 *= norm.z;
  g11 *= norm.w;
  float n00 = dot(g00, vec2(fx.x, fy.x));
  float n10 = dot(g10, vec2(fx.y, fy.y));
  float n01 = dot(g01, vec2(fx.z, fy.z));
  float n11 = dot(g11, vec2(fx.w, fy.w));
  vec2 fade_xy = fade(Pf.xy);
  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
  return 2.3 * n_xy;
}

float transitionMask(vec2 uv){
  // Match the plugin shader: prog is intentionally constant.
  float prog = 0.4;
  float noise = cnoise(vec2((uv.x * (uMultiX)) + uStartX, (uv.y * (uMultiY)) + uStartY)) * 3.0;
  float mask = mix(1.0, (noise + prog), uStart0);
  mask *= uStart2;
  return clamp(mask, 0.0, 1.0);
}

void main(void) {

    float scrollModifier = scroll*scrollSpeed;
    float time = globaltime * timescale;
    vec2 center = vec2(sin(TWO_PI * time * 0.2), cos(TWO_PI * time * 0.2)) * nsin(time * 0.3) * 0.5;
    vec2 tx = (gl_FragCoord.xy / resolution.xy - 0.5 - center) * vec2(aspect, 1.0);
    float len = 1.0 - length(tx);
    float zoom = 1.0 + scrollModifier - len * 3.0 * (1.0 - scrollModifier) + len * velocity * 2.0;

    vec4 imgColor = texture2D(
            texture,
            rotate(
                    (tx + center) * vec2(1.0, -1.0) * zoom,
                    twist * TWO_PI * nsin(len + time) * scrollModifier + time
            ) + 0.5
    );

    if (doInvertImage == 1) {
        imgColor.rgb = vec3(1.0) - imgColor.rgb;  // Invert the color if doInvertImage is true
    }

    // Apply the non-uniform dark/light transition on top of the existing WebGL background.
    // mask=0 => keep original, mask=1 => darkened.
    vec2 uv = gl_FragCoord.xy / resolution.xy;
    float mask = transitionMask(uv);
    vec3 darkVariant = imgColor.rgb * 0.08; // keep a hint of texture; tune to taste
    imgColor.rgb = mix(imgColor.rgb, darkVariant, mask);

    gl_FragColor = imgColor;
}
</script>

{% endif %}